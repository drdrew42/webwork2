#!/usr/bin/perl
use strict;
use warnings;
use feature 'say';
 
use Moo;
use MooX::Options;
use File::Find::Rule;
use List::MoreUtils qw/first_index/;
use Data::Dump qw/dd/;
use File::Slurp qw/read_file/;
use MongoDB;
use YAML qw(LoadFile);
use Carp::Always;
use Path::Class;

use lib '../lib';

use Models::Library::Constant qw/$DATABASE $COURSE/;
use Models::Library::Problem;


use Utils::PGParse;

option dbtype => (is=>'ro', format=>'s',default=>"MONGO");
option library_directory => (is=>'ro',format=>'s');
option library_base => (is=>'ro',format=>'s');
option dbname => (is=>'ro',format=>'s', default => 'testOPL');
option action => (is=>'ro', format => 's');
option dbuser => (is=>'ro',format => 's', default=>'webworkWrite');
option dbpass => (is=>'ro',format => 's', default=>'passwordRW');
option find_in_db => (is=> 'ro',format=>'s@', repeatable=> 1, autosplit=>";");

my @dbtables = qw/OPL_DBsubject OPL_DBchapter OPL_DBsection OPL_author OPL_textbook OPL_chapter OPL_section OPL_problem 
                    OPL_keyword OPL_path OPL_morelt OPL_pgfile OPL_pgfile_problem OPL_pgfile_keyword/;
my @subjects;
my @chapters;
my $taxon;
my $logfile = 'opl.log';

sub run {
    my $self = shift;

    open LOGFH, '>', $logfile or die "Could not open $logfile: $!";

    $DATABASE->{type} = $self->dbtype;

    # Connect to database
    if ($DATABASE->{type} eq "MYSQL"){
        my $dbname = $self->dbname;
        my $dbuser = $self->dbuser;
        my $dbpass = $self->dbpass;
        print "connecting to MYSQL database with database name: $dbname and user: $dbuser\n";
        DBIx::Mint->connect("dbi:mysql:dbname=$dbname", $dbuser,$dbpass, {
            AutoCommit    => 1,
            RaiseError    => 1,
        });
    } elsif ($DATABASE->{type} eq "MONGO") {
        $DATABASE->{MONGOclient} = MongoDB::MongoClient->new;
        $DATABASE->{dbname} = $self->dbname;
    } else {
        die "The database type $DATABASE->{type} is not allowed.  Only MYSQL and MONGO have been defined.";
    }

    if(defined($self->action) && $self->action eq 'rebuildDB') {
        $self->rebuildDB;
    } elsif(defined($self->action) && $self->action eq 'search') {
        die "The option find must be defined" unless defined($self->find_in_db);
        $self->search;
    } else {
        my $action = $self->action || '' ;
        die "The only options are 'rebuildDB' and 'search'.  You selected $action";
    }
    
    close LOGFH;
}

sub rebuildDB {
    my $self = shift;
    my $start = time();
    
    print "Building a database of type: $DATABASE->{type} \n"; 


    $| = 1;  # disable the print buffer

    my $taxfile ='tax.yml';
    my $tbLinkFile = 'textbooks.yml';

    $COURSE->{library_base} = '/Library/WebServer/Documents/webwork/libraries/webwork-open-problem-library/OpenProblemLibrary/';
    #my $default_dir = 'WHFreeman/Rogawski_Calculus_Early_Transcendentals_Second_Edition/11_Parametric_Equations_Polar_Coordinates_and_Conic_Sections/11.4_Area_and_Arc_Length_in_Polar_Coordinates';
    #my $default_dir = '/Library/WebServer/Documents/webwork/libraries/webwork-open-problem-library/OpenProblemLibrary/Rochester';
    my $default_dir = '.';
    my $lib_dir = $self->library_directory || $default_dir; 
    my $dir = dir($COURSE->{library_base},$lib_dir)->cleanup;
    print "Building the OPL database for the library found at:\n " . $dir->stringify . "\n";

    
    
    $self->recreateDB();


    print "Loading the Taxonomy File: $taxfile \n";
    $taxon = LoadFile($taxfile);
    @subjects = map { $_->{name} } @{$taxon->{subjects}};
    @chapters =(); 

    # load the textbook link file
    print "Loading the Textbooks File: $tbLinkFile \n";
    my $tb_link_file = LoadFile($tbLinkFile);
    
    my $dir = dir($COURSE->{library_base},$lib_dir)->cleanup;
    
    say $dir->stringify;
    
    my @pgfiles = File::Find::Rule->file()->name('*.pg')->in($dir->stringify);

    my $path = dir($COURSE->{library_directory},$pgfiles[0]);

    print "Rebuilding the Database... \n";
    for my $i (0 .. $#pgfiles) {
        my $prob = Utils::PGParse::parse($pgfiles[$i],$tb_link_file);
        my $file = file($pgfiles[$i]);
        my $relFile = $file->relative(dir($COURSE->{library_base}));
        $prob->path($relFile->stringify);
        
        printf "%6s",$i if ($i>0 && $i % 100 == 0);
        print "\n" if ($i>0 && $i % 1000 == 0);
        if (! $prob->isLink){
            if(valid($prob,$taxon,$i)){
              $prob->insert;
            } else {
                print LOGFH "This problem is not written to the database: " . $prob->path . "\n";
            }
        }
    }

    print "\nLibrary database rebuilt.\n";
        
    if($DATABASE->{type} eq 'MONGO') {
        print "building indexes in MONGO\n";
        my $idx = Tie::IxHash->new(DBsubject => 1, DBchapter => 1, DBsection => 1, keyword=>1, level=>1);
        my $db = $DATABASE->{MONGOclient}->get_database($DATABASE->{dbname});
        my $problems = $db->get_collection('problems');
        $problems->ensure_index($idx);
        $problems->ensure_index({statement => "text"}, {language_override=>"DDDD"}); # make a dummy language field
    }
    my $timediff = time() - $start;

    print "Amount of time is $timediff seconds.\n";

}

sub recreateDB {
    my $self = shift; 
    print "Recreating the Database tables\n";
    
    my $dbname = $self->dbname || 'testOPL';
    
    if($DATABASE->{type} eq 'MYSQL'){
        my $mint  = DBIx::Mint->instance;  

        ## drop all of the tables
        my $dbh  = $mint->dbh;

        for my $table (@dbtables) {
            #print "DROP TABLE IF EXISTS $table ;\n";
            $dbh->do('DROP TABLE IF EXISTS '.$table.';');
        }
        ## then create them
        my $buildDB = read_file('setup_db.sql');
        my @commands = split(';',$buildDB);

        for my $command (@commands){
            #print "command: " . $command . "\n";
            $dbh->do($command.';');
        }
    } elsif($DATABASE->{type} eq 'MONGO'){
        my $db = $DATABASE->{MONGOclient}->get_database($DATABASE->{dbname});
        my $problems = $db->get_collection('problems');
        $problems->remove({});  # remove all problems;
        my $tbprobs = $db->get_collection('textbook_problems');
        $tbprobs->remove({});
        
    }
    print "Finished recreating the Database tables\n";
}

sub valid {
    my ($prob,$taxon,$i) = @_;
    #if(! defined($prob->DBinfo)){
    #    return;
    #}
    if($prob->DBinfo->DBsubject  eq "ZZZ-Inserted Text" && 
        $prob->DBinfo->DBchapter  eq "ZZZ-Inserted Text" && 
        $prob->DBinfo->DBsection  eq "ZZZ-Inserted Text") {
        return "";
    }
    if($prob->DBinfo->DBsubject  eq "" && 
        $prob->DBinfo->DBchapter  eq "" && 
        $prob->DBinfo->DBsection  eq "") {
        return "";
    }

    
    my $name = $prob->DBinfo->DBsubject;
    my $sname = "subject";  # name of the subject, chapter or section 
    my $sub_found = first_index { $_ eq $prob->DBinfo->DBsubject} @subjects;
    #print $name . " " . $prob->path . "\n";
    if ($sub_found > -1) {
        $name = $prob->DBinfo->DBchapter; 
        $sname = "chapter";
        
        @chapters = map { $_->{name} }  @{$taxon->{subjects}[$sub_found]->{chapters}};
        my $chap_found = first_index { $_ eq $prob->DBinfo->DBchapter} @chapters;
        
        if($chap_found > -1 ) {
            $name = $prob->DBinfo->DBchapter;
            $sname = "chapter";
            if($taxon->{subjects}[$sub_found]->{chapters}[$chap_found]->{sections}){
                my @sections = @{$taxon->{subjects}[$sub_found]->{chapters}[$chap_found]->{sections}};
                #push(@sections,@valid_names);
                $name = $prob->DBinfo->DBsection;
                $sname = "section"; 
                my $sect_found = first_index { $_ eq $prob->DBinfo->DBsection} @sections;
                #print $sect_found . "\n";
                if ($sect_found > -1 ) {
                    return 1; 
                } else {
                    $name = $prob->DBinfo->DBsection;
                    $sname = "section"; 
                }
            } else {
                return 1;
            }
        } 
    }

    return 1;
}

my @fields = qw/DBsubject DBchapter DBsection lastname firstname institution level keyword/;

sub search {
    my $self = shift;
    my $params = {};
    for my $obj (@{$self->find_in_db}){
        my @results = split(":",$obj);
        if(grep {$_ eq $results[0] } @fields){
            $params->{$results[0]} = $results[1];
        } else {
            die "The field " . $results[0] . " is not an available search term.";
        }
    }
    dd $params; 
    my @find = Models::Library::Problem->find($params);
    
    ##dd scalar(@find);
}

main->new_with_options->run;

1;